<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PilotView</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
    <style>
        :root {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-card-hover: #f1f5f9;
            --bg-sidebar: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --accent: #6366f1;
            --accent-light: #818cf8;
            --accent-dark: #4f46e5;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            background-color: var(--bg-body);
            color: var(--text-primary);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        .navbar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            padding: 0.75rem 0;
        }
        
        .navbar-brand {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-primary) !important;
            letter-spacing: -0.025em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .navbar-brand .brand-icon {
            width: 38px;
            height: 38px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.1rem;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }
        
        .navbar-brand:hover .brand-icon {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        .navbar-brand .brand-icon,
        .navbar-brand {
            transition: all 0.2s ease;
        }
        
        .navbar .settings-btn {
            background: var(--bg-card-hover);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .navbar .settings-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: var(--shadow-sm);
        }
        
        .navbar .timezone-badge {
            background: var(--bg-card-hover) !important;
            color: var(--text-secondary) !important;
            font-weight: 500;
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
        }
        
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
        }
        
        .card:hover {
            box-shadow: var(--shadow-md);
        }
        
        .card-header {
            background-color: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .route-card {
            cursor: pointer;
            border-radius: 10px !important;
        }
        
        .route-card:hover {
            background-color: var(--bg-card-hover);
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        
        .segment-btn {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            transition: all 0.2s ease;
            min-width: 50px;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .segment-btn:hover {
            background-color: var(--bg-card-hover);
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .segment-btn.active {
            background-color: var(--accent);
            border-color: var(--accent);
            color: white;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.3);
        }
        
        .segment-btn.playing {
            background-color: var(--success);
            border-color: var(--success);
            color: white;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .log-entry {
            font-family: 'SF Mono', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.8rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: var(--bg-card-hover);
            border-radius: 8px;
            border-left: 3px solid var(--accent);
        }
        
        .log-entry.initData { border-left-color: #14b8a6; background-color: #f0fdfa; }
        .log-entry.carState { border-left-color: #0ea5e9; background-color: #f0f9ff; }
        .log-entry.controlsState { border-left-color: #22c55e; background-color: #f0fdf4; }
        .log-entry.gpsLocationExternal, .log-entry.gpsLocation { border-left-color: #eab308; background-color: #fefce8; }
        .log-entry.deviceState { border-left-color: #8b5cf6; background-color: #faf5ff; }
        .log-entry.clocks { border-left-color: #ec4899; background-color: #fdf2f8; }
        
        .log-time {
            color: var(--text-muted);
            font-size: 0.7rem;
        }
        
        .log-type {
            font-weight: 600;
            color: var(--accent-dark);
        }
        
        .log-data {
            color: var(--text-secondary);
            word-break: break-all;
        }
        
        .time-info {
            background: linear-gradient(135deg, #f0fdfa 0%, #ecfeff 100%);
            border: 1px solid #99f6e4;
            border-radius: 12px;
            padding: 1.25rem;
        }
        
        .time-info h6 {
            color: #0d9488;
            font-weight: 600;
        }
        
        .file-badge {
            font-size: 0.7rem;
            margin-right: 0.25rem;
        }
        
        .video-container {
            background-color: #0f172a;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: var(--shadow-lg);
        }
        
        video {
            width: 100%;
            display: block;
        }
        
        .video-overlay {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(4px);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: white;
            font-weight: 500;
            z-index: 10;
            pointer-events: none;
        }
        
        /* Plyr customizations */
        .plyr {
            --plyr-color-main: var(--accent);
            --plyr-video-background: #0f172a;
            border-radius: 12px;
        }
        
        .plyr--video .plyr__controls {
            background: linear-gradient(transparent, rgba(15, 23, 42, 0.9));
        }
        
        /* Custom progress bar styling for streaming */
        .plyr__progress input[type="range"] {
            color: var(--accent);
        }
        
        .plyr__progress__container {
            flex: 1;
        }
        
        .plyr__control--overlaid {
            background: var(--accent) !important;
        }
        
        .plyr__control--overlaid:hover {
            background: var(--accent-light) !important;
        }
        
        .video-error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 2rem;
            z-index: 20;
            border-radius: 12px;
        }
        
        .video-error-overlay i {
            font-size: 3rem;
            color: var(--warning);
            margin-bottom: 1rem;
        }
        
        .video-error-overlay h5 {
            margin-bottom: 0.5rem;
        }
        
        .video-error-overlay p {
            color: var(--text-muted);
            margin-bottom: 1rem;
            max-width: 400px;
        }
        
        .video-error-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .video-error-buttons .btn {
            min-width: 120px;
        }
        
        #retry-video-btn.retrying {
            pointer-events: none;
            opacity: 0.7;
        }
        
        #retry-video-btn .spinner-border {
            width: 0.875rem;
            height: 0.875rem;
            border-width: 2px;
        }
        
        .codec-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .codec-badge.h264 {
            background-color: var(--success);
            color: white;
        }
        
        .codec-badge.hevc {
            background-color: var(--warning);
            color: #1e293b;
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            border: none;
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.3);
        }
        
        .btn-accent:hover {
            background: linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 100%);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.4);
        }
        
        .spinner-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        
        .spinner-border {
            color: var(--accent) !important;
        }
        
        .config-input {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .config-input:focus {
            background-color: var(--bg-card);
            border-color: var(--accent);
            color: var(--text-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }
        
        .empty-state i {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: var(--text-muted);
            opacity: 0.6;
        }
        
        .empty-state h4 {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .log-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .log-filters .btn {
            font-size: 0.75rem;
            padding: 0.35rem 0.85rem;
            border-radius: 20px;
            font-weight: 500;
        }
        
        .log-filters .btn.active {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .log-scroll {
            max-height: 400px;
            overflow-y: auto;
        }
        
        #map {
            height: 300px;
            border-radius: 8px;
            z-index: 1;
        }
        
        .map-container {
            position: relative;
        }
        
        .map-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        /* Current position marker on map */
        .position-marker-dot {
            width: 20px;
            height: 20px;
            background: #f97316;
            border: 3px solid #fff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.5), 0 0 0 2px rgba(249, 115, 22, 0.3);
            animation: position-pulse 2s infinite;
        }
        
        @keyframes position-pulse {
            0%, 100% {
                box-shadow: 0 2px 8px rgba(249, 115, 22, 0.5), 0 0 0 2px rgba(249, 115, 22, 0.3);
            }
            50% {
                box-shadow: 0 2px 12px rgba(249, 115, 22, 0.7), 0 0 0 6px rgba(249, 115, 22, 0.2);
            }
        }
        
        .current-position-marker {
            z-index: 1000 !important;
            /* Smooth transition for marker position */
            transition: transform 0.05s linear !important;
        }
        
        /* Also apply to the leaflet marker icon container */
        .leaflet-marker-icon.current-position-marker {
            transition: transform 0.05s linear !important;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-body);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
        
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding: 0.5rem;
            background-color: var(--bg-card-hover);
            border-radius: 8px;
        }
        
        .playback-controls .btn {
            border-radius: 8px;
        }
        
        .segment-progress {
            flex: 1;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .segment-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            transition: width 0.1s;
            border-radius: 3px;
        }
        
        .form-check-input:checked {
            background-color: var(--accent);
            border-color: var(--accent);
        }
        
        .form-check-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 0.2rem rgba(99, 102, 241, 0.25);
        }
        
        .badge.bg-success {
            background-color: var(--success) !important;
        }
        
        /* Steering Wheel Visualization */
        .steering-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 12px;
            margin-top: 1rem;
        }
        
        .steering-wheel-wrapper {
            position: relative;
            width: 180px;
            height: 180px;
        }
        
        .steering-wheel {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .steering-wheel-outer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 12px solid #475569;
            border-radius: 50%;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .steering-wheel-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            border-radius: 50%;
            border: 3px solid #475569;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #94a3b8;
        }
        
        .steering-wheel-spoke {
            position: absolute;
            background: linear-gradient(to right, #475569 0%, #334155 100%);
            border-radius: 4px;
        }
        
        .steering-wheel-spoke.horizontal {
            width: 100%;
            height: 14px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        .steering-wheel-spoke.vertical {
            width: 14px;
            height: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 0);
        }
        
        .steering-wheel-rotator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.05s ease-out;
        }
        
        /* Desired angle indicator (ghost wheel) */
        .steering-wheel-desired {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.4;
            pointer-events: none;
        }
        
        .steering-wheel-desired .steering-wheel-outer {
            border-color: #22c55e;
            box-shadow: 
                inset 0 0 20px rgba(34, 197, 94, 0.3),
                0 0 20px rgba(34, 197, 94, 0.2);
        }
        
        .steering-wheel-desired .steering-wheel-spoke {
            background: linear-gradient(to right, #22c55e 0%, #16a34a 100%);
        }
        
        .steering-info {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-width: 200px;
        }
        
        .steering-info-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid transparent;
        }
        
        .steering-info-row.actual {
            border-left-color: #64748b;
        }
        
        .steering-info-row.desired {
            border-left-color: #22c55e;
        }
        
        .steering-info-row.differential {
            border-left-color: #f59e0b;
        }
        
        .steering-info-label {
            font-size: 0.75rem;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .steering-info-value {
            font-size: 1.25rem;
            font-weight: 600;
            font-family: 'SF Mono', 'Monaco', monospace;
        }
        
        .steering-info-row.actual .steering-info-value {
            color: #e2e8f0;
        }
        
        .steering-info-row.desired .steering-info-value {
            color: #22c55e;
        }
        
        .steering-info-row.differential .steering-info-value {
            color: #f59e0b;
        }
        
        .steering-info-unit {
            font-size: 0.7rem;
            color: #64748b;
            margin-left: 2px;
        }
        
        .steering-speed {
            text-align: center;
            padding: 0.5rem;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }
        
        .steering-speed-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #818cf8;
            font-family: 'SF Mono', 'Monaco', monospace;
        }
        
        .steering-speed-label {
            font-size: 0.65rem;
            color: #94a3b8;
            text-transform: uppercase;
        }
        
        .steering-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .steering-status.engaged {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }
        
        .steering-status.disengaged {
            background: rgba(100, 116, 139, 0.15);
            color: #94a3b8;
        }
        
        .steering-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        .steering-status.engaged .steering-status-dot {
            animation: pulse-dot 1.5s infinite;
        }
        
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.8); }
        }
        
        .badge.bg-secondary {
            background-color: var(--text-secondary) !important;
        }
        
        .text-secondary {
            color: var(--text-secondary) !important;
        }
        
        .text-info {
            color: var(--accent) !important;
        }
        
        .alert-warning {
            background-color: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }
        
        .alert-danger {
            background-color: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }
        
        .alert-success {
            background-color: #d1fae5;
            border-color: #6ee7b7;
            color: #065f46;
        }
        
        .btn-outline-light {
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .btn-outline-light:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: white;
            border-color: white;
        }
        
        /* Modal styling */
        .modal-content {
            border-radius: 16px;
            border: none;
            box-shadow: var(--shadow-lg);
        }
        
        .modal-header {
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-card);
            border-radius: 16px 16px 0 0;
        }
        
        .modal-footer {
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-card);
            border-radius: 0 0 16px 16px;
        }
        
        .btn-close {
            filter: none;
        }
        
        /* Form select styling */
        .form-select {
            border-radius: 8px;
            border-color: var(--border-color);
        }
        
        .form-select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }
        
        /* Routes list styling */
        #routes-container {
            background-color: var(--bg-card-hover);
            border-radius: 8px;
            padding: 0.5rem !important;
        }
        
        #routes-container .card {
            box-shadow: none;
        }
        
        /* Section headers */
        .card-header h6 {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .card-header h6 i {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <nav class="navbar sticky-top">
        <div class="container-fluid px-4">
            <a class="navbar-brand" href="#">
                <span class="brand-icon">
                    <i class="bi bi-car-front-fill"></i>
                </span>
                <span>PilotView</span>
            </a>
            <div class="d-flex align-items-center gap-3">
                <span class="timezone-badge" id="timezone-display"></span>
                <button class="settings-btn" data-bs-toggle="modal" data-bs-target="#configModal">
                    <i class="bi bi-gear me-1"></i> Settings
                </button>
            </div>
        </div>
    </nav>

    <div class="container-fluid py-4">
        <div class="row">
            <!-- Routes List -->
            <div class="col-lg-3 col-xl-2 mb-4">
                <div class="card">
                    <div class="card-header">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6 class="mb-0"><i class="bi bi-list-ul me-2"></i>Routes</h6>
                            <button class="btn btn-sm btn-accent" onclick="loadRoutes()">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="use-gps-time" checked onchange="loadRoutes()">
                            <label class="form-check-label small" for="use-gps-time">
                                <i class="bi bi-clock-history me-1"></i>Correct time
                            </label>
                        </div>
                    </div>
                    <div class="card-body p-2" id="routes-container" style="max-height: 70vh; overflow-y: auto;">
                        <div class="spinner-container">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Route Details -->
            <div class="col-lg-9 col-xl-10">
                <div id="route-details" style="display: none;">
                    <!-- Time Info Row -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <div class="time-info h-100">
                                <h6><i class="bi bi-clock me-2"></i>Time Information</h6>
                                <p class="mb-1"><strong>Start Time:</strong> <span id="corrected-time">-</span></p>
                                <p class="mb-1"><strong>Time Source:</strong> <span id="time-source">-</span></p>
                                <p class="mb-0"><strong>Segments:</strong> <span id="segment-count">-</span> | <strong>Dongle:</strong> <span id="dongle-id">-</span></p>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <!-- Map -->
                            <div class="card h-100">
                                <div class="card-header py-2">
                                    <h6 class="mb-0"><i class="bi bi-map me-2"></i>Route Map</h6>
                                </div>
                                <div class="card-body p-0 map-container">
                                    <div id="map"></div>
                                    <div class="map-loading" id="map-loading" style="display: none;">
                                        <div class="spinner-border" role="status"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Segments -->
                    <div class="card mb-4">
                        <div class="card-header py-2">
                            <div class="d-flex justify-content-between align-items-center">
                                <h6 class="mb-0"><i class="bi bi-collection me-2"></i>Segments</h6>
                                <div class="form-check form-switch mb-0">
                                    <input class="form-check-input" type="checkbox" id="auto-play" checked>
                                    <label class="form-check-label small" for="auto-play">Auto-play next</label>
                                </div>
                            </div>
                        </div>
                        <div class="card-body py-2">
                            <div id="segments-container" class="d-flex flex-wrap gap-1">
                                <!-- Segment buttons will be inserted here -->
                            </div>
                        </div>
                    </div>

                    <!-- Video & Logs -->
                    <div class="row">
                        <!-- Video -->
                        <div class="col-lg-7 mb-4">
                            <div class="card h-100">
                                <div class="card-header d-flex justify-content-between align-items-center py-2">
                                    <h6 class="mb-0"><i class="bi bi-camera-video me-2"></i>Video</h6>
                                    <div class="d-flex align-items-center gap-2">
                                        <span class="codec-badge h264" id="codec-badge">H.264</span>
                                        <select class="form-select form-select-sm config-input" style="width: auto;" id="camera-select">
                                            <option value="qcamera" selected>Quick Camera (H.264)</option>
                                            <option value="fcamera">Front Camera (HEVC)</option>
                                            <option value="ecamera">Wide Camera (HEVC)</option>
                                            <option value="dcamera">Driver Camera (HEVC)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div class="video-container" id="video-wrapper">
                                        <video id="video-player" playsinline>
                                            <p>Your browser does not support video playback.</p>
                                        </video>
                                        <div class="video-overlay" id="video-overlay">
                                            <span id="current-segment-display">Segment 0</span>
                                        </div>
                                        <div class="video-error-overlay" id="video-error" style="display: none;">
                                            <i class="bi bi-exclamation-triangle-fill" id="error-icon"></i>
                                            <div class="spinner-border text-warning" id="retry-spinner" style="display: none; width: 3rem; height: 3rem; margin-bottom: 1rem;" role="status">
                                                <span class="visually-hidden">Retrying...</span>
                                            </div>
                                            <h5 id="error-title">Video Cannot Play</h5>
                                            <p id="video-error-message">This HEVC video format is not supported by your browser.</p>
                                            <div class="video-error-buttons">
                                                <button class="btn btn-outline-light btn-sm" id="retry-video-btn" onclick="retryVideo()">
                                                    <i class="bi bi-arrow-clockwise me-1"></i><span id="retry-btn-text">Retry</span>
                                                </button>
                                                <button class="btn btn-accent btn-sm" id="switch-camera-btn" onclick="switchToCompatibleCamera()">
                                                    <i class="bi bi-play-circle me-1"></i>Switch to Quick Camera (H.264)
                                                </button>
                                            </div>
                                            <small id="retry-status" class="text-muted mt-2" style="display: none;"></small>
                                        </div>
                                    </div>
                                    <div class="playback-controls">
                                        <button class="btn btn-sm btn-outline-secondary" id="prev-segment" title="Previous segment (Shift+Left)">
                                            <i class="bi bi-skip-backward-fill"></i>
                                        </button>
                                        <div class="segment-progress">
                                            <div class="segment-progress-bar" id="segment-progress-bar" style="width: 0%"></div>
                                        </div>
                                        <button class="btn btn-sm btn-outline-secondary" id="next-segment" title="Next segment (Shift+Right)">
                                            <i class="bi bi-skip-forward-fill"></i>
                                        </button>
                                        <span class="small text-secondary" id="video-info"></span>
                                    </div>
                                    <div id="hevc-warning" class="alert alert-warning mt-2 py-2 small" style="display: none;">
                                        <i class="bi bi-exclamation-triangle me-1"></i>
                                        <strong>HEVC video selected.</strong> This format may not play in Chrome/Firefox. 
                                        <a href="#" onclick="switchToCompatibleCamera(); return false;" class="alert-link">Switch to Quick Camera (H.264)</a> for best compatibility.
                                    </div>
                                    <div id="streaming-info" class="alert alert-success mt-2 py-2 small" style="display: none;">
                                        <i class="bi bi-broadcast me-1"></i>
                                        <strong>Server-side streaming active.</strong> Video is converted to MP4 for browser playback.
                                        <span id="hw-accel-badge"></span>
                                    </div>
                                    <div class="mt-2 small text-muted">
                                        <i class="bi bi-keyboard me-1"></i>
                                        <strong>Shortcuts:</strong> Space (play/pause) • Left/Right (seek 5s) • Shift+Left/Right (prev/next segment) • F (fullscreen)
                                    </div>
                                    
                                    <!-- Steering Wheel Visualization -->
                                    <div class="steering-container" id="steering-container">
                                        <div class="steering-wheel-wrapper">
                                            <div class="steering-wheel">
                                                <!-- Desired angle (ghost wheel behind) -->
                                                <div class="steering-wheel-desired" id="steering-wheel-desired">
                                                    <div class="steering-wheel-rotator" id="desired-rotator">
                                                        <div class="steering-wheel-outer"></div>
                                                        <div class="steering-wheel-spoke horizontal"></div>
                                                        <div class="steering-wheel-spoke vertical"></div>
                                                    </div>
                                                </div>
                                                <!-- Actual steering wheel -->
                                                <div class="steering-wheel-rotator" id="actual-rotator">
                                                    <div class="steering-wheel-outer"></div>
                                                    <div class="steering-wheel-spoke horizontal"></div>
                                                    <div class="steering-wheel-spoke vertical"></div>
                                                    <div class="steering-wheel-inner">
                                                        <i class="bi bi-car-front"></i>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="steering-info">
                                            <div class="steering-status disengaged" id="steering-status">
                                                <span class="steering-status-dot"></span>
                                                <span id="steering-status-text">Disengaged</span>
                                            </div>
                                            
                                            <div class="steering-info-row actual">
                                                <span class="steering-info-label">Actual Angle</span>
                                                <span>
                                                    <span class="steering-info-value" id="actual-angle">0.0</span>
                                                    <span class="steering-info-unit">°</span>
                                                </span>
                                            </div>
                                            
                                            <div class="steering-info-row desired">
                                                <span class="steering-info-label">Desired Angle</span>
                                                <span>
                                                    <span class="steering-info-value" id="desired-angle">0.0</span>
                                                    <span class="steering-info-unit">°</span>
                                                </span>
                                            </div>
                                            
                                            <div class="steering-info-row differential">
                                                <span class="steering-info-label">Differential</span>
                                                <span>
                                                    <span class="steering-info-value" id="angle-differential">0.0</span>
                                                    <span class="steering-info-unit">°</span>
                                                </span>
                                            </div>
                                            
                                            <div class="steering-speed">
                                                <div class="steering-speed-value" id="vehicle-speed">0</div>
                                                <div class="steering-speed-label">km/h</div>
                                            </div>
                                            <div class="small text-muted mt-2" id="steering-debug" style="font-size: 0.65rem; color: #64748b;">
                                                Loading...
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Logs -->
                        <div class="col-lg-5 mb-4">
                            <div class="card h-100">
                                <div class="card-header py-2">
                                    <h6 class="mb-0"><i class="bi bi-terminal me-2"></i>Logs</h6>
                                </div>
                                <div class="card-body">
                                    <div class="log-filters" id="log-filters">
                                        <button class="btn btn-outline-secondary btn-sm active" data-type="all">All</button>
                                        <button class="btn btn-outline-info btn-sm" data-type="initData">init</button>
                                        <button class="btn btn-outline-primary btn-sm" data-type="carState">car</button>
                                        <button class="btn btn-outline-success btn-sm" data-type="controlsState">ctrl</button>
                                        <button class="btn btn-outline-warning btn-sm" data-type="gps">GPS</button>
                                        <button class="btn btn-outline-dark btn-sm" data-type="deviceState">device</button>
                                    </div>
                                    <div class="log-scroll" id="logs-container">
                                        <div class="empty-state">
                                            <i class="bi bi-journal-text"></i>
                                            <p>Select a segment to view logs</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Empty State -->
                <div id="empty-state" class="empty-state">
                    <i class="bi bi-car-front"></i>
                    <h4>Select a Route</h4>
                    <p>Choose a route from the list to view segments, videos, and logs.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Config Modal -->
    <div class="modal fade" id="configModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="bi bi-gear me-2" style="color: var(--accent);"></i>Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="data-dir-input" class="form-label fw-medium">Data Directory</label>
                        <input type="text" class="form-control config-input" id="data-dir-input" 
                               placeholder="/data/media/0/realdata">
                        <div class="form-text">
                            Path to the comma device realdata folder (local or mounted).
                        </div>
                    </div>
                    <div id="dir-status" class="alert" role="alert" style="display: none;">
                    </div>
                    
                    <hr>
                    
                    <div class="mb-3">
                        <label class="form-label fw-medium">Server Capabilities</label>
                        <div id="capabilities-status">
                            <div class="d-flex align-items-center gap-2 mb-2">
                                <span id="ffmpeg-status-icon" class="badge bg-secondary">
                                    <i class="bi bi-x-circle"></i>
                                </span>
                                <span><strong>FFmpeg Transcoding</strong></span>
                            </div>
                            <div class="form-text" id="ffmpeg-status-text">
                                Checking...
                            </div>
                        </div>
                    </div>
                    
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-accent" onclick="saveConfig()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
    <script>
        // State
        let currentRoute = null;
        let currentRouteData = null;
        let currentSegment = null;
        let allLogs = [];
        let activeFilter = 'all';
        let timeCorrection = null;
        let map = null;
        let routePolyline = null;
        let positionMarker = null;
        let currentPositionMarker = null;  // Marker for current video position
        let gpsPoints = [];
        let player = null;
        let currentCameraType = 'qcamera';
        let videoError = false;
        let serverCapabilities = { ffmpeg: false, streaming: false };
        
        // Steering data state
        let steeringData = [];
        let steeringUpdateInterval = null;
        let lastActualAngle = 0;
        let lastDesiredAngle = 0;
        let lastSpeed = 0;
        let isEngaged = false;

        // Get timezone info
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        document.getElementById('timezone-display').textContent = userTimezone;

        // Format time with timezone
        function formatTimeWithTZ(date) {
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        // API calls
        async function fetchApi(endpoint, options = {}) {
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        // Check server capabilities (FFmpeg availability)
        async function checkCapabilities() {
            try {
                serverCapabilities = await fetchApi('/api/capabilities');
                console.log('Server capabilities:', serverCapabilities);
                updateCapabilitiesDisplay();
            } catch (error) {
                console.error('Failed to check capabilities:', error);
                serverCapabilities = { ffmpeg: false, streaming: false };
                updateCapabilitiesDisplay();
            }
        }
        
        // Update capabilities display in settings modal
        function updateCapabilitiesDisplay() {
            const statusIcon = document.getElementById('ffmpeg-status-icon');
            const statusText = document.getElementById('ffmpeg-status-text');
            
            if (serverCapabilities.ffmpeg) {
                const hwAccel = serverCapabilities.hardware_acceleration || {};
                const cache = serverCapabilities.cache || {};
                
                let accelInfo = '';
                if (hwAccel.available) {
                    let accelName = hwAccel.type || 'Hardware';
                    if (hwAccel.type === 'apple_silicon_videotoolbox') {
                        accelName = 'Apple Silicon VideoToolbox';
                    } else if (hwAccel.type === 'videotoolbox') {
                        accelName = 'VideoToolbox';
                    } else if (hwAccel.type === 'nvenc') {
                        accelName = 'NVIDIA NVENC';
                    }
                    accelInfo = ` <span class="badge bg-info"><i class="bi bi-lightning-charge me-1"></i>${accelName}</span>`;
                }
                
                let cacheInfo = '';
                if (cache.files > 0) {
                    cacheInfo = `<br><small class="text-muted">Cache: ${cache.files} files (${cache.size_mb} MB)</small>
                    <button class="btn btn-outline-danger btn-sm ms-2" onclick="clearVideoCache()">Clear</button>`;
                }
                
                statusIcon.className = 'badge bg-success';
                statusIcon.innerHTML = '<i class="bi bi-check-circle"></i>';
                statusText.innerHTML = `
                    <span class="text-success"><i class="bi bi-check me-1"></i>Available</span>${accelInfo}
                    <br><small class="text-muted">Videos are cached for seeking support.</small>${cacheInfo}
                `;
            } else {
                statusIcon.className = 'badge bg-warning';
                statusIcon.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
                statusText.innerHTML = `
                    <span class="text-warning"><i class="bi bi-x me-1"></i>Not available</span> - 
                    Install FFmpeg to enable video transcoding.
                    <br><code class="small">brew install ffmpeg</code> (macOS) or <code class="small">apt install ffmpeg</code> (Linux)
                `;
            }
        }
        
        async function clearVideoCache() {
            if (!confirm('Clear all cached videos?')) return;
            try {
                const response = await fetch('/api/cache/clear', { method: 'POST' });
                const result = await response.json();
                alert(result.message);
                await checkCapabilities();
            } catch (err) {
                console.error('Failed to clear cache:', err);
            }
        }

        // Initialize map
        function initMap() {
            if (map) {
                map.remove();
            }
            map = L.map('map').setView([37.7749, -122.4194], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);
        }

        // Load GPS data and display on map
        async function loadGpsData(routeName) {
            document.getElementById('map-loading').style.display = 'block';
            
            try {
                const data = await fetchApi(`/api/routes/${encodeURIComponent(routeName)}/gps`);
                gpsPoints = data.points;
                
                if (gpsPoints.length > 0) {
                    // Log GPS data info for debugging
                    console.log(`GPS data loaded: ${gpsPoints.length} points`);
                    if (gpsPoints[0].t !== undefined) {
                        console.log('GPS points have relative time (t) field - aligned with video time');
                    }
                    
                    // Clear previous route
                    if (routePolyline) {
                        map.removeLayer(routePolyline);
                    }
                    if (positionMarker) {
                        map.removeLayer(positionMarker);
                    }
                    if (currentPositionMarker) {
                        map.removeLayer(currentPositionMarker);
                        currentPositionMarker = null;
                    }
                    
                    // Create polyline
                    const latlngs = gpsPoints.map(p => [p.lat, p.lon]);
                    routePolyline = L.polyline(latlngs, {
                        color: '#6366f1',
                        weight: 4,
                        opacity: 0.9
                    }).addTo(map);
                    
                    // Add start/end markers
                    L.marker(latlngs[0], {
                        icon: L.divIcon({
                            className: 'start-marker',
                            html: '<i class="bi bi-geo-alt-fill" style="color: #10b981; font-size: 24px; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));"></i>',
                            iconSize: [24, 24],
                            iconAnchor: [12, 24]
                        })
                    }).addTo(map).bindPopup('Start');
                    
                    L.marker(latlngs[latlngs.length - 1], {
                        icon: L.divIcon({
                            className: 'end-marker',
                            html: '<i class="bi bi-geo-alt-fill" style="color: #ef4444; font-size: 24px; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));"></i>',
                            iconSize: [24, 24],
                            iconAnchor: [12, 24]
                        })
                    }).addTo(map).bindPopup('End');
                    
                    // Create current position marker (initially hidden)
                    currentPositionMarker = L.marker(latlngs[0], {
                        icon: L.divIcon({
                            className: 'current-position-marker',
                            html: '<div class="position-marker-dot"></div>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        }),
                        zIndexOffset: 1000
                    }).addTo(map).bindPopup('Current Position');
                    
                    // Fit bounds
                    map.fitBounds(routePolyline.getBounds(), { padding: [20, 20] });
                } else {
                    // No GPS data - show message
                    if (routePolyline) map.removeLayer(routePolyline);
                }
            } catch (error) {
                console.error('Error loading GPS data:', error);
            } finally {
                document.getElementById('map-loading').style.display = 'none';
            }
        }
        
        // Find GPS position at a given video time (in seconds from segment start)
        // Returns interpolated position for smooth movement
        // The backend now provides 't' field which is aligned with video time
        function getGpsAtTime(segmentNum, videoTimeSeconds) {
            if (!gpsPoints || gpsPoints.length === 0) {
                return null;
            }
            
            // Filter GPS points for this segment
            const segmentGps = gpsPoints.filter(p => p.segment === segmentNum);
            
            if (segmentGps.length === 0) {
                // No GPS data for this segment
                return null;
            }
            
            // Find the two GPS points that bracket the target time
            // Using 't' field which is relative time within segment (aligned with video)
            let before = null;
            let after = null;
            
            for (let i = 0; i < segmentGps.length; i++) {
                const point = segmentGps[i];
                const pointTime = point.t !== undefined ? point.t : 0;
                
                if (pointTime <= videoTimeSeconds) {
                    before = { ...point, _pointTime: pointTime };
                } else {
                    after = { ...point, _pointTime: pointTime };
                    break;
                }
            }
            
            // If we don't have both points, return the closest one
            if (!before && !after) {
                return null;
            }
            if (!before) {
                return after;
            }
            if (!after) {
                return before;
            }
            
            // Interpolate between the two points
            const timeDiff = after._pointTime - before._pointTime;
            if (timeDiff === 0) {
                return before;
            }
            
            // Calculate interpolation factor
            const t = Math.max(0, Math.min(1, (videoTimeSeconds - before._pointTime) / timeDiff));
            
            return {
                lat: before.lat + (after.lat - before.lat) * t,
                lon: before.lon + (after.lon - before.lon) * t,
                speed: before.speed !== null && after.speed !== null 
                    ? before.speed + (after.speed - before.speed) * t 
                    : (before.speed || after.speed),
                bearing: before.bearing !== null && after.bearing !== null
                    ? before.bearing + (after.bearing - before.bearing) * t
                    : (before.bearing || after.bearing),
                segment: segmentNum,
                _t: t,
                _videoTime: videoTimeSeconds,
                _beforeTime: before._pointTime,
                _afterTime: after._pointTime
            };
        }
        
        // Update the current position marker based on video time
        let lastMapUpdateLog = 0;
        function updateMapPosition(segmentNum, videoTimeSeconds) {
            if (!currentPositionMarker || !map) return;
            
            const gpsPoint = getGpsAtTime(segmentNum, videoTimeSeconds);
            
            if (gpsPoint) {
                const latlng = L.latLng(gpsPoint.lat, gpsPoint.lon);
                currentPositionMarker.setLatLng(latlng);
                
                // Debug logging (every 2 seconds)
                const now = Date.now();
                if (now - lastMapUpdateLog > 2000) {
                    lastMapUpdateLog = now;
                    console.log(`Map position: seg=${segmentNum}, videoTime=${videoTimeSeconds.toFixed(2)}s, lat=${gpsPoint.lat.toFixed(6)}, lon=${gpsPoint.lon.toFixed(6)}, t=${gpsPoint._t?.toFixed(3) || 'N/A'}`);
                }
                
                // Update popup content with speed and bearing
                let popupContent = 'Current Position';
                if (gpsPoint.speed !== null) {
                    const speedKmh = (gpsPoint.speed * 3.6).toFixed(0);
                    popupContent += `<br>Speed: ${speedKmh} km/h`;
                }
                if (gpsPoint.bearing !== null) {
                    popupContent += `<br>Bearing: ${gpsPoint.bearing.toFixed(0)}°`;
                }
                currentPositionMarker.setPopupContent(popupContent);
            }
        }

        // Load configuration
        async function loadConfig() {
            const config = await fetchApi('/api/config');
            document.getElementById('data-dir-input').value = config.dataDir;
            updateDirStatus(config.exists);
        }

        // Save configuration
        async function saveConfig() {
            const dataDir = document.getElementById('data-dir-input').value;
            const config = await fetchApi('/api/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dataDir })
            });
            updateDirStatus(config.exists);
            if (config.exists) {
                bootstrap.Modal.getInstance(document.getElementById('configModal')).hide();
                loadRoutes();
            }
        }

        function updateDirStatus(exists) {
            const status = document.getElementById('dir-status');
            status.style.display = 'block';
            if (exists) {
                status.className = 'alert alert-success';
                status.innerHTML = '<i class="bi bi-check-circle me-2"></i>Directory found!';
            } else {
                status.className = 'alert alert-danger';
                status.innerHTML = '<i class="bi bi-x-circle me-2"></i>Directory not found.';
            }
        }

        // Load routes
        async function loadRoutes() {
            const container = document.getElementById('routes-container');
            const useGpsTime = document.getElementById('use-gps-time').checked;
            
            container.innerHTML = `
                <div class="spinner-container">
                    <div class="spinner-border spinner-border-sm" role="status"></div>
                    <small class="text-secondary mt-2">Loading routes...</small>
                </div>
            `;

            try {
                const url = useGpsTime ? '/api/routes?with_time_correction=true' : '/api/routes';
                const data = await fetchApi(url);
                
                if (data.routes.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state py-4">
                            <i class="bi bi-folder2-open" style="font-size: 2rem;"></i>
                            <p class="small">No routes found</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = data.routes.map(route => {
                    // Use millisecond timestamp for proper timezone handling
                    const displayTime = route.corrected_start_timestamp_ms 
                        ? formatTimeWithTZ(new Date(route.corrected_start_timestamp_ms))
                        : (route.route_time ? formatDateTime(route.route_time) : route.name);
                    const timeSource = route.time_source 
                        ? `<span class="badge bg-success ms-1" title="Time from ${route.time_source}"><i class="bi bi-check"></i></span>` 
                        : '';
                    
                    return `
                        <div class="card route-card mb-2" onclick="selectRoute('${route.name}')">
                            <div class="card-body p-2">
                                <div class="d-flex justify-content-between align-items-start">
                                    <div>
                                        <small class="d-block">${displayTime}${timeSource}</small>
                                        <small class="text-secondary">
                                            <i class="bi bi-collection me-1"></i>${route.segment_count} seg
                                        </small>
                                    </div>
                                    <i class="bi bi-chevron-right text-secondary"></i>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                container.innerHTML = `
                    <div class="alert alert-danger small">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        Failed to load routes
                    </div>
                `;
            }
        }

        // Select route
        async function selectRoute(routeName) {
            currentRoute = routeName;
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('route-details').style.display = 'block';

            // Initialize map if not already
            if (!map) {
                initMap();
            }

            try {
                // Load route details, time correction, and GPS data in parallel
                const [route, timeData] = await Promise.all([
                    fetchApi(`/api/routes/${encodeURIComponent(routeName)}`),
                    fetchApi(`/api/routes/${encodeURIComponent(routeName)}/time`)
                ]);

                currentRouteData = route;
                timeCorrection = timeData;

                // Load GPS data asynchronously
                loadGpsData(routeName);

                // Update route info
                document.getElementById('segment-count').textContent = route.segment_count;
                document.getElementById('dongle-id').textContent = route.dongle_id || 'N/A';

                // Update time correction info - use baseTimeMs (milliseconds) for proper timezone
                if (timeData.baseTimeMs) {
                    document.getElementById('corrected-time').textContent = 
                        formatTimeWithTZ(new Date(timeData.baseTimeMs));
                } else {
                    document.getElementById('corrected-time').textContent = 'Not available';
                }
                document.getElementById('time-source').textContent = timeData.timeSource || 'Unknown';

                // Render segments
                const segmentsContainer = document.getElementById('segments-container');
                segmentsContainer.innerHTML = route.segments.map(seg => {
                    const hasQcamera = seg.files.qcamera ? 'bg-success' : '';
                    return `
                        <button class="btn btn-sm segment-btn ${hasQcamera}" 
                                onclick="selectSegment(${seg.segment_num})" 
                                data-segment="${seg.segment_num}"
                                title="Segment ${seg.segment_num}">
                            ${seg.segment_num}
                        </button>
                    `;
                }).join('');

                // Auto-select first segment
                if (route.segments.length > 0) {
                    selectSegment(route.segments[0].segment_num);
                }
            } catch (error) {
                console.error('Error loading route:', error);
            }
        }

        // Select segment
        async function selectSegment(segmentNum) {
            currentSegment = segmentNum;

            // Update button states
            document.querySelectorAll('.segment-btn').forEach(btn => {
                btn.classList.remove('active', 'playing');
                if (parseInt(btn.dataset.segment) === segmentNum) {
                    btn.classList.add('active');
                }
            });

            // Update segment display
            document.getElementById('current-segment-display').textContent = `Segment ${segmentNum}`;
            
            // Update progress bar
            if (currentRouteData) {
                const progress = ((segmentNum + 1) / currentRouteData.segment_count) * 100;
                document.getElementById('segment-progress-bar').style.width = `${progress}%`;
            }

            try {
                const segment = await fetchApi(
                    `/api/routes/${encodeURIComponent(currentRoute)}/segments/${segmentNum}`
                );

                // Load video
                loadVideo(segment);
                
                // Update map position to start of segment
                updateMapPosition(segmentNum, 0);

                // Load logs and steering data in parallel
                loadLogs(segmentNum);
                loadSteeringData(segmentNum).then((data) => {
                    // Update steering wheel with initial data
                    if (steeringData.length > 0) {
                        // Get data from 1 second in to ensure we have values
                        const initialData = getSteeringAtTime(1.0);
                        console.log('Initial steering data at t=1.0s:', initialData);
                        
                        updateSteeringWheel(
                            initialData.actual ?? 0,
                            initialData.desired,
                            initialData.speed ?? 0,
                            initialData.enabled ?? false
                        );
                        
                        // Show a brief toast/alert if we got valid data
                        if (initialData.actual !== null) {
                            console.log(`Steering wheel initialized: actual=${initialData.actual.toFixed(1)}°, desired=${initialData.desired?.toFixed(1) ?? 'N/A'}°`);
                        }
                    } else {
                        console.warn('No steering data loaded for this segment');
                    }
                });
                
                // Reset steering display immediately while loading
                updateSteeringWheel(0, null, 0, false);
            } catch (error) {
                console.error('Error loading segment:', error);
            }
        }

        // Load video
        function loadVideo(segment) {
            const video = document.getElementById('video-player');
            const cameraSelect = document.getElementById('camera-select');
            const videoInfo = document.getElementById('video-info');
            const hevcWarning = document.getElementById('hevc-warning');
            const streamingInfo = document.getElementById('streaming-info');
            const codecBadge = document.getElementById('codec-badge');
            const videoErrorEl = document.getElementById('video-error');
            
            // Reset retry count for new video
            resetRetryCount();
            
            // Hide error overlay and info alerts
            videoErrorEl.style.display = 'none';
            hevcWarning.style.display = 'none';
            streamingInfo.style.display = 'none';
            
            let selectedCamera = cameraSelect.value;
            currentCameraType = selectedCamera;
            
            // Determine if this is an HEVC camera
            const isHEVC = selectedCamera !== 'qcamera';
            
            // Check if streaming is available (FFmpeg)
            const useStreaming = serverCapabilities.streaming;
            
            // Try to use selected camera, or fall back to any available camera
            if (!segment.files[selectedCamera]) {
                // Fall back to any available camera (prefer HEVC cameras for quality)
                const available = ['fcamera', 'ecamera', 'dcamera', 'qcamera'].find(c => segment.files[c]);
                if (available) {
                    selectedCamera = available;
                    cameraSelect.value = available;
                    currentCameraType = available;
                }
            }
            
            // Determine codec badge based on streaming
            const currentIsHEVC = selectedCamera !== 'qcamera';
            if (useStreaming) {
                // All videos are streamed as H.264 MP4
                codecBadge.textContent = 'H.264';
                codecBadge.className = 'codec-badge h264';
                streamingInfo.style.display = 'block';
                
                // Show hardware acceleration badge if available (only for HEVC which needs transcoding)
                const hwAccelBadge = document.getElementById('hw-accel-badge');
                const hwAccel = serverCapabilities.hardware_acceleration || {};
                if (currentIsHEVC && hwAccel.available) {
                    let accelName = 'HW Accelerated';
                    if (hwAccel.type === 'apple_silicon_videotoolbox') {
                        accelName = 'Apple Silicon';
                    } else if (hwAccel.type === 'videotoolbox') {
                        accelName = 'VideoToolbox';
                    } else if (hwAccel.type === 'nvenc') {
                        accelName = 'NVENC';
                    } else if (hwAccel.type === 'vaapi') {
                        accelName = 'VAAPI';
                    } else if (hwAccel.type === 'qsv') {
                        accelName = 'Quick Sync';
                    }
                    hwAccelBadge.innerHTML = `<span class="badge bg-info ms-1"><i class="bi bi-lightning-charge"></i> ${accelName}</span>`;
                } else if (currentIsHEVC) {
                    hwAccelBadge.innerHTML = '<span class="badge bg-secondary ms-1">CPU</span>';
                } else {
                    // qcamera just needs remuxing (no transcoding)
                    hwAccelBadge.innerHTML = '<span class="badge bg-info ms-1">Remux</span>';
                }
            } else {
                // No streaming - show warning for HEVC
                codecBadge.textContent = currentIsHEVC ? 'HEVC' : 'H.264';
                codecBadge.className = `codec-badge ${currentIsHEVC ? 'hevc' : 'h264'}`;
                if (currentIsHEVC) {
                    hevcWarning.style.display = 'block';
                }
            }
            
            // Store current segment data for potential camera switch
            window.currentSegmentData = segment;
            
            if (segment.files[selectedCamera]) {
                const filePath = segment.files[selectedCamera].path;
                const relativePath = filePath.split('/').slice(-2).join('/');
                
                // Determine endpoint - always use streaming when available
                let videoUrl, mimeType;
                
                if (useStreaming) {
                    // Use streaming endpoint for all videos (HEVC transcoded, TS remuxed to MP4)
                    videoUrl = `/api/stream/${relativePath}`;
                    mimeType = 'video/mp4';
                } else {
                    // Direct file endpoint (may not work in all browsers)
                    videoUrl = `/api/file/${relativePath}`;
                    mimeType = selectedCamera === 'qcamera' ? 'video/mp2t' : 'video/hevc';
                }
                
                video.type = mimeType;
                
                // Store for cache polling
                window.currentVideoPath = relativePath;
                window.currentVideoUrl = videoUrl;
                
                // Fetch video info and handle caching
                if (useStreaming) {
                    fetch(`/api/video-info/${relativePath}`)
                        .then(response => response.json())
                        .then(info => {
                            let statusBadge = '';
                            
                            if (info.cached) {
                                // Cached - full seeking available
                                statusBadge = '<span class="badge bg-success ms-1">Ready</span>';
                                window.currentVideoDuration = null; // Use native duration
                                stopCachePolling();
                            } else if (info.transcoding) {
                                // Being cached - poll for completion
                                statusBadge = '<span class="badge bg-warning ms-1">Caching...</span>';
                                window.currentVideoDuration = 60;
                                startCachePolling(relativePath);
                            } else {
                                // Starting cache
                                statusBadge = '<span class="badge bg-info ms-1">Streaming</span>';
                                window.currentVideoDuration = 60;
                                startCachePolling(relativePath);
                            }
                            
                            videoInfo.innerHTML = `${segment.files[selectedCamera].filename} (${formatFileSize(segment.files[selectedCamera].size)}) ${statusBadge}`;
                            video.src = videoUrl;
                        })
                        .catch(err => {
                            console.log('Could not fetch video info:', err);
                            video.src = videoUrl;
                            videoInfo.innerHTML = `${segment.files[selectedCamera].filename} (${formatFileSize(segment.files[selectedCamera].size)})`;
                        });
                } else {
                    video.src = videoUrl;
                    videoInfo.innerHTML = `${segment.files[selectedCamera].filename} (${formatFileSize(segment.files[selectedCamera].size)})`;
                }
            } else {
                video.src = '';
                videoInfo.innerHTML = `<i class="bi bi-exclamation-triangle me-1"></i>No video available`;
            }
        }
        
        // Cache polling
        let cachePollingInterval = null;
        
        function startCachePolling(relativePath) {
            stopCachePolling();
            
            cachePollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/video-info/${relativePath}`);
                    const info = await response.json();
                    
                    if (info.cached) {
                        console.log('Cache ready! Reloading for seeking support...');
                        stopCachePolling();
                        
                        // Update badge
                        const videoInfo = document.getElementById('video-info');
                        if (videoInfo) {
                            videoInfo.innerHTML = videoInfo.innerHTML
                                .replace(/Caching\.\.\./g, 'Ready')
                                .replace(/Streaming/g, 'Ready')
                                .replace(/bg-warning/g, 'bg-success')
                                .replace(/bg-info/g, 'bg-success');
                        }
                        
                        // Reload video with cache busting to get seekable version
                        const video = document.getElementById('video-player');
                        const currentTime = video.currentTime;
                        const wasPlaying = !video.paused;
                        
                        window.currentVideoDuration = null; // Use native duration now
                        
                        video.src = `${window.currentVideoUrl}?t=${Date.now()}`;
                        video.load();
                        
                        video.addEventListener('loadedmetadata', function onLoad() {
                            video.removeEventListener('loadedmetadata', onLoad);
                            console.log(`Reloaded from cache. Duration: ${video.duration}s`);
                            if (currentTime > 0 && currentTime < video.duration) {
                                video.currentTime = currentTime;
                            }
                            if (wasPlaying) {
                                video.play();
                            }
                        }, { once: true });
                    }
                } catch (err) {
                    console.log('Cache poll error:', err);
                }
            }, 2000);
        }
        
        function stopCachePolling() {
            if (cachePollingInterval) {
                clearInterval(cachePollingInterval);
                cachePollingInterval = null;
            }
        }
        
        // Switch to compatible camera (H.264 qcamera)
        
        function switchToCompatibleCamera() {
            const cameraSelect = document.getElementById('camera-select');
            cameraSelect.value = 'qcamera';
            
            if (window.currentSegmentData && window.currentSegmentData.files.qcamera) {
                loadVideo(window.currentSegmentData);
            }
        }
        
        // Auto-retry configuration
        const MAX_RETRIES = 3;
        const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff: 1s, 2s, 4s
        let currentRetryCount = 0;
        let retryTimeoutId = null;
        
        // Reset retry count when loading a new video
        function resetRetryCount() {
            currentRetryCount = 0;
            if (retryTimeoutId) {
                clearTimeout(retryTimeoutId);
                retryTimeoutId = null;
            }
        }
        
        // Retry loading the current video
        function retryVideo() {
            if (window.currentSegmentData) {
                const video = document.getElementById('video-player');
                const videoErrorOverlay = document.getElementById('video-error');
                const retryStatus = document.getElementById('retry-status');
                
                // Hide error overlay during retry
                videoErrorOverlay.style.display = 'none';
                
                // Reload the video source with cache-busting parameter
                const currentSrc = video.src;
                const separator = currentSrc.includes('?') ? '&' : '?';
                const newSrc = currentSrc.replace(/[&?]_retry=\d+/, '') + separator + '_retry=' + Date.now();
                
                video.src = newSrc;
                video.load();
                video.play().catch(() => {}); // Ignore autoplay errors
            }
        }
        
        // Handle video errors with auto-retry
        function handleVideoError(e) {
            const video = document.getElementById('video-player');
            const videoErrorOverlay = document.getElementById('video-error');
            const videoErrorMessage = document.getElementById('video-error-message');
            const cameraSelect = document.getElementById('camera-select');
            const retryStatus = document.getElementById('retry-status');
            const retryBtn = document.getElementById('retry-video-btn');
            const retryBtnText = document.getElementById('retry-btn-text');
            
            // Only show error for HEVC videos without streaming (qcamera should work)
            const isHEVC = currentCameraType !== 'qcamera';
            const isStreaming = isHEVC && serverCapabilities.streaming;
            
            if (video.error) {
                // Check if error is retryable (network/streaming issues, not codec issues)
                const isRetryable = isStreaming || 
                    video.error.code === MediaError.MEDIA_ERR_NETWORK ||
                    (video.error.code === MediaError.MEDIA_ERR_DECODE && isStreaming);
                
                // Auto-retry if we haven't exceeded max retries and error is retryable
                if (isRetryable && currentRetryCount < MAX_RETRIES) {
                    currentRetryCount++;
                    const delay = RETRY_DELAYS[currentRetryCount - 1] || RETRY_DELAYS[RETRY_DELAYS.length - 1];
                    
                    console.log(`Video error, auto-retrying in ${delay}ms (attempt ${currentRetryCount}/${MAX_RETRIES})`);
                    
                    // Show retry status with spinner
                    const errorIcon = document.getElementById('error-icon');
                    const retrySpinner = document.getElementById('retry-spinner');
                    const errorTitle = document.getElementById('error-title');
                    
                    videoErrorOverlay.style.display = 'flex';
                    errorIcon.style.display = 'none';
                    retrySpinner.style.display = 'inline-block';
                    errorTitle.textContent = 'Retrying...';
                    videoErrorMessage.textContent = `Attempt ${currentRetryCount} of ${MAX_RETRIES}`;
                    retryStatus.style.display = 'block';
                    retryStatus.textContent = `Waiting ${delay/1000}s before retry...`;
                    retryBtn.style.display = 'none';
                    
                    // Hide switch button during retry
                    const switchBtn = document.getElementById('switch-camera-btn');
                    if (switchBtn) switchBtn.style.display = 'none';
                    
                    retryTimeoutId = setTimeout(() => {
                        retryStatus.textContent = 'Retrying now...';
                        retryVideo();
                    }, delay);
                    
                    return;
                }
                
                // Max retries exceeded or non-retryable error - show final error
                const errorIcon = document.getElementById('error-icon');
                const retrySpinner = document.getElementById('retry-spinner');
                const errorTitle = document.getElementById('error-title');
                
                // Reset to error state
                errorIcon.style.display = 'inline-block';
                retrySpinner.style.display = 'none';
                errorTitle.textContent = 'Video Cannot Play';
                
                let message = '';
                
                if (isStreaming) {
                    // Streaming failed - FFmpeg issue
                    message = 'Video streaming failed. The server may be having trouble transcoding this video.';
                    if (currentRetryCount >= MAX_RETRIES) {
                        message += ` (${MAX_RETRIES} retries failed)`;
                    }
                } else if (isHEVC) {
                    // Native HEVC playback failed
                    if (video.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
                        message = 'Your browser cannot play HEVC (H.265) video. Chrome and Firefox have limited HEVC support.';
                    } else if (video.error.code === MediaError.MEDIA_ERR_DECODE) {
                        message = 'Failed to decode HEVC video. Your browser may lack the required codec.';
                    } else {
                        message = 'This HEVC (H.265) video format is not supported by your browser.';
                    }
                } else {
                    // H.264 playback failed - unusual
                    message = 'Failed to play video. The file may be corrupted or in an unsupported format.';
                    if (currentRetryCount >= MAX_RETRIES) {
                        message += ` (${MAX_RETRIES} retries failed)`;
                    }
                }
                
                videoErrorMessage.textContent = message;
                retryStatus.style.display = 'none';
                
                // Show retry button for manual retry
                retryBtn.style.display = 'inline-flex';
                retryBtnText.textContent = 'Retry';
                retryBtn.onclick = () => {
                    currentRetryCount = 0; // Reset for manual retry
                    retryVideo();
                };
                
                // Show switch button only if qcamera is available and we're not already using it
                const switchBtn = document.getElementById('switch-camera-btn');
                if (currentCameraType !== 'qcamera' && window.currentSegmentData && window.currentSegmentData.files.qcamera) {
                    switchBtn.style.display = 'inline-flex';
                } else if (currentCameraType !== 'qcamera') {
                    switchBtn.style.display = 'none';
                    videoErrorMessage.textContent += ' Quick Camera (H.264) is not available for this segment.';
                } else {
                    switchBtn.style.display = 'none';
                }
                
                videoErrorOverlay.style.display = 'flex';
            }
        }
        
        // Initialize Plyr video player
        function initPlayer() {
            const video = document.getElementById('video-player');
            
            // Initialize Plyr with options
            player = new Plyr(video, {
                controls: [
                    'play-large',
                    'play',
                    'progress',
                    'current-time',
                    'duration',
                    'mute',
                    'volume',
                    'settings',
                    'pip',
                    'fullscreen'
                ],
                settings: ['speed'],
                speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 2] },
                keyboard: { focused: true, global: false },
                tooltips: { controls: true, seek: true },
                invertTime: false,
                seekTime: 5
            });
            
            // Fix duration display for streaming (cached files have correct duration)
            function updateDurationDisplay() {
                // Only override if we're streaming (not cached)
                if (window.currentVideoDuration) {
                    const durationDisplay = document.querySelector('.plyr__time--duration');
                    if (durationDisplay) {
                        durationDisplay.textContent = '01:00';
                    }
                }
            }
            
            player.on('loadedmetadata', () => {
                const videoEl = document.getElementById('video-player');
                console.log(`Video loaded. Native duration: ${videoEl.duration}s, using override: ${window.currentVideoDuration ? 'yes' : 'no'}`);
                updateDurationDisplay();
            });
            
            // Keep duration display updated while streaming
            player.on('timeupdate', updateDurationDisplay);
            
            // Handle video ended for auto-play next segment
            player.on('ended', () => {
                if (document.getElementById('auto-play').checked && currentRouteData) {
                    const nextSegment = currentSegment + 1;
                    if (nextSegment < currentRouteData.segment_count) {
                        const nextSeg = currentRouteData.segments.find(s => s.segment_num === nextSegment);
                        if (nextSeg) {
                            selectSegment(nextSegment);
                            setTimeout(() => player.play(), 100);
                        }
                    }
                }
            });
            
            // Handle playing state
            player.on('playing', () => {
                document.querySelectorAll('.segment-btn').forEach(btn => {
                    if (parseInt(btn.dataset.segment) === currentSegment) {
                        btn.classList.add('playing');
                    }
                });
                // Start steering updates when video plays
                startSteeringUpdates();
            });
            
            // Handle pause state
            player.on('pause', () => {
                document.querySelectorAll('.segment-btn.playing').forEach(btn => {
                    btn.classList.remove('playing');
                });
                // Stop steering updates when video pauses
                stopSteeringUpdates();
            });
            
            // Update steering and map position on seek
            player.on('seeked', () => {
                const videoTime = player.currentTime;
                const steeringAtTime = getSteeringAtTime(videoTime);
                updateSteeringWheel(
                    steeringAtTime.actual,
                    steeringAtTime.desired,
                    steeringAtTime.speed,
                    steeringAtTime.enabled
                );
                // Update map position
                if (currentSegment !== null) {
                    updateMapPosition(currentSegment, videoTime);
                }
            });
            
            // Handle video errors
            player.on('error', handleVideoError);
            
            // Also listen on the video element directly for error events
            video.addEventListener('error', handleVideoError);
        }
        
        // Global keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                // Shift + Arrow keys for segment navigation
                if (e.shiftKey) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        document.getElementById('prev-segment').click();
                    } else if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        document.getElementById('next-segment').click();
                    }
                }
            });
        }

        // Navigation buttons
        document.getElementById('prev-segment').addEventListener('click', () => {
            if (currentSegment > 0) {
                selectSegment(currentSegment - 1);
            }
        });

        document.getElementById('next-segment').addEventListener('click', () => {
            if (currentRouteData && currentSegment < currentRouteData.segment_count - 1) {
                selectSegment(currentSegment + 1);
            }
        });

        // Camera select change handler
        document.getElementById('camera-select').addEventListener('change', async () => {
            if (currentRoute && currentSegment !== null) {
                const segment = await fetchApi(
                    `/api/routes/${encodeURIComponent(currentRoute)}/segments/${currentSegment}`
                );
                loadVideo(segment);
            }
        });

        // Load steering data for segment
        async function loadSteeringData(segmentNum) {
            const container = document.getElementById('steering-container');
            const debugEl = document.getElementById('steering-debug');
            
            if (debugEl) debugEl.textContent = 'Loading steering data...';
            
            try {
                const url = `/api/routes/${encodeURIComponent(currentRoute)}/segments/${segmentNum}/steering`;
                console.log('Fetching steering data from:', url);
                
                const data = await fetchApi(url);
                steeringData = data.data || [];
                
                const debugInfo = {
                    total: data.count,
                    actualCount: data.actualCount,
                    desiredCount: data.desiredCount,
                    nonZeroActual: data.nonZeroActual,
                    nonZeroDesired: data.nonZeroDesired,
                    messageTypes: data.messageTypesSeen
                };
                console.log(`Steering data loaded:`, debugInfo);
                
                // Update visible debug indicator
                if (debugEl) {
                    debugEl.textContent = `Data: ${data.actualCount} actual, ${data.desiredCount} desired (${data.nonZeroActual || 0} non-zero)`;
                    if (data.sampleAngles && data.sampleAngles.length > 0) {
                        const sample = data.sampleAngles[0];
                        debugEl.textContent += ` | Sample: ${sample.angle?.toFixed(1) ?? 'null'}°`;
                    }
                }
                
                // Show sample angles from backend
                if (data.sampleAngles && data.sampleAngles.length > 0) {
                    console.log('Backend sample angles:', data.sampleAngles);
                    
                    // Immediately test display with first sample angle
                    const firstSample = data.sampleAngles[0];
                    if (firstSample && firstSample.angle !== null && firstSample.angle !== undefined) {
                        console.log(`Testing steering wheel display with angle: ${firstSample.angle}°`);
                        updateSteeringWheel(firstSample.angle, null, firstSample.speed || 0, false);
                    }
                } else {
                    console.warn('No sample angles returned from backend');
                    if (debugEl) debugEl.textContent += ' | No samples!';
                }
                
                // Show/hide steering container based on data availability
                if (data.actualCount > 0) {
                    container.style.opacity = '1';
                    
                    // Sample data points at different times to verify values
                    const actualData = steeringData.filter(d => d.type === 'actual');
                    const desiredData = steeringData.filter(d => d.type === 'desired');
                    
                    // Get samples from start, middle, and end
                    const sampleActual = [
                        actualData[0],
                        actualData[Math.floor(actualData.length / 2)],
                        actualData[actualData.length - 1]
                    ].filter(Boolean);
                    
                    const sampleDesired = [
                        desiredData[0],
                        desiredData[Math.floor(desiredData.length / 2)],
                        desiredData[desiredData.length - 1]
                    ].filter(Boolean);
                    
                    // Check if all angles are 0
                    const nonZeroActual = actualData.filter(d => d.angle !== 0 && d.angle !== null);
                    const nonZeroDesired = desiredData.filter(d => d.angle !== 0 && d.angle !== null);
                    
                    console.log('Sample actual data (start/mid/end):', sampleActual);
                    console.log('Sample desired data (start/mid/end):', sampleDesired);
                    console.log(`Non-zero angles: actual=${nonZeroActual.length}/${actualData.length}, desired=${nonZeroDesired.length}/${desiredData.length}`);
                    
                    if (nonZeroActual.length === 0 && actualData.length > 0) {
                        console.warn('WARNING: All actual steering angles are 0! Data might not be reading correctly.');
                    }
                } else {
                    container.style.opacity = '0.5';
                    console.warn('No actual steering angle data (carState) found in this segment');
                }
                
                if (data.desiredCount === 0) {
                    console.warn('No desired steering angle data (controlsState/carControl) found in this segment');
                    // Hide the desired wheel if no data
                    document.getElementById('steering-wheel-desired').style.display = 'none';
                } else {
                    document.getElementById('steering-wheel-desired').style.display = 'block';
                }
                
                if (data.error) {
                    console.error('Server error loading steering data:', data.error);
                    if (debugEl) debugEl.textContent = `Error: ${data.error}`;
                }
                
                return data;
            } catch (error) {
                console.error('Error loading steering data:', error);
                steeringData = [];
                container.style.opacity = '0.5';
                if (debugEl) debugEl.textContent = `Failed to load: ${error.message}`;
                return null;
            }
        }
        
        // Find steering data at specific time
        function getSteeringAtTime(time) {
            if (!steeringData || steeringData.length === 0) {
                return { actual: null, desired: null, speed: null, enabled: null };
            }
            
            // Find the most recent actual and desired values at or before the given time
            let actual = null;
            let desired = null;
            let speed = null;
            let enabled = null;
            
            for (const entry of steeringData) {
                if (entry.t > time) break;
                
                if (entry.type === 'actual') {
                    if (entry.angle !== null && entry.angle !== undefined) {
                        actual = entry.angle;
                    }
                    if (entry.speed !== null && entry.speed !== undefined) {
                        speed = entry.speed;
                    }
                } else if (entry.type === 'desired') {
                    if (entry.angle !== null && entry.angle !== undefined) {
                        desired = entry.angle;
                    }
                    if (entry.enabled !== null && entry.enabled !== undefined) {
                        enabled = entry.enabled;
                    }
                }
            }
            
            return { actual, desired, speed, enabled };
        }
        
        // Update steering wheel visualization
        function updateSteeringWheel(actualAngle, desiredAngle, speed, enabled) {
            // Debug: log first few updates
            if (typeof updateSteeringWheel.callCount === 'undefined') {
                updateSteeringWheel.callCount = 0;
            }
            updateSteeringWheel.callCount++;
            if (updateSteeringWheel.callCount <= 5) {
                console.log(`updateSteeringWheel called #${updateSteeringWheel.callCount}:`, { actualAngle, desiredAngle, speed, enabled });
            }
            
            const actualRotator = document.getElementById('actual-rotator');
            const desiredRotator = document.getElementById('desired-rotator');
            const actualAngleEl = document.getElementById('actual-angle');
            const desiredAngleEl = document.getElementById('desired-angle');
            const differentialEl = document.getElementById('angle-differential');
            const speedEl = document.getElementById('vehicle-speed');
            const statusEl = document.getElementById('steering-status');
            const statusTextEl = document.getElementById('steering-status-text');
            const desiredWheelEl = document.getElementById('steering-wheel-desired');
            
            // Check if elements exist
            if (!actualRotator || !actualAngleEl) {
                console.error('Steering wheel elements not found in DOM!');
                return;
            }
            
            // Update actual angle
            if (actualAngle !== null) {
                lastActualAngle = actualAngle;
                // Rotate wheel - steering angles are typically inverted for display
                // (negative angle = turn right, but we rotate clockwise for right)
                actualRotator.style.transform = `rotate(${-actualAngle}deg)`;
                actualAngleEl.textContent = actualAngle.toFixed(1);
            }
            
            // Update desired angle
            if (desiredAngle !== null) {
                lastDesiredAngle = desiredAngle;
                desiredRotator.style.transform = `rotate(${-desiredAngle}deg)`;
                desiredAngleEl.textContent = desiredAngle.toFixed(1);
                desiredWheelEl.style.display = 'block';
            } else {
                desiredWheelEl.style.display = 'none';
                desiredAngleEl.textContent = '-';
            }
            
            // Update differential
            if (actualAngle !== null && desiredAngle !== null) {
                const diff = desiredAngle - actualAngle;
                differentialEl.textContent = (diff >= 0 ? '+' : '') + diff.toFixed(1);
            } else {
                differentialEl.textContent = '-';
            }
            
            // Update speed (convert m/s to km/h)
            if (speed !== null) {
                lastSpeed = speed;
                const speedKmh = speed * 3.6;
                speedEl.textContent = speedKmh.toFixed(0);
            }
            
            // Update engagement status
            isEngaged = enabled === true;
            if (isEngaged) {
                statusEl.className = 'steering-status engaged';
                statusTextEl.textContent = 'Engaged';
            } else {
                statusEl.className = 'steering-status disengaged';
                statusTextEl.textContent = 'Disengaged';
            }
        }
        
        // Start steering update loop synced to video
        function startSteeringUpdates() {
            // Clear any existing interval
            if (steeringUpdateInterval) {
                clearInterval(steeringUpdateInterval);
            }
            
            console.log('Starting steering updates, data points:', steeringData.length);
            
            // Update steering display and map position based on video time
            let updateCount = 0;
            steeringUpdateInterval = setInterval(() => {
                if (!player || !player.playing) return;
                
                const videoTime = player.currentTime;
                const steeringAtTime = getSteeringAtTime(videoTime);
                
                // Log occasionally to debug
                if (updateCount % 100 === 0) {
                    console.log(`Steering update at t=${videoTime.toFixed(2)}s:`, steeringAtTime);
                }
                updateCount++;
                
                updateSteeringWheel(
                    steeringAtTime.actual,
                    steeringAtTime.desired,
                    steeringAtTime.speed,
                    steeringAtTime.enabled
                );
                
                // Update map position every frame (interpolation handles smoothness)
                if (currentSegment !== null) {
                    updateMapPosition(currentSegment, videoTime);
                }
            }, 50); // Update at ~20Hz for smooth animation
        }
        
        // Stop steering updates
        function stopSteeringUpdates() {
            if (steeringUpdateInterval) {
                clearInterval(steeringUpdateInterval);
                steeringUpdateInterval = null;
            }
        }
        
        // Load logs
        async function loadLogs(segmentNum) {
            const container = document.getElementById('logs-container');
            container.innerHTML = `
                <div class="spinner-container py-4">
                    <div class="spinner-border spinner-border-sm" role="status"></div>
                </div>
            `;

            try {
                const data = await fetchApi(
                    `/api/routes/${encodeURIComponent(currentRoute)}/segments/${segmentNum}/logs?limit=500`
                );
                
                allLogs = data.messages;
                renderLogs();
            } catch (error) {
                container.innerHTML = `
                    <div class="alert alert-danger small">
                        Failed to load logs: ${error.message}
                    </div>
                `;
            }
        }

        // Render logs with filter
        function renderLogs() {
            const container = document.getElementById('logs-container');
            
            let filteredLogs = allLogs;
            if (activeFilter !== 'all') {
                if (activeFilter === 'gps') {
                    filteredLogs = allLogs.filter(log => 
                        log.type === 'gpsLocationExternal' || log.type === 'gpsLocation'
                    );
                } else {
                    filteredLogs = allLogs.filter(log => log.type === activeFilter);
                }
            }

            if (filteredLogs.length === 0) {
                container.innerHTML = `
                    <div class="empty-state py-4">
                        <i class="bi bi-journal-text" style="font-size: 2rem;"></i>
                        <p class="small">No logs matching filter</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = filteredLogs.slice(0, 200).map(log => {
                const time = formatLogTime(log.logMonoTime);
                const realTime = convertMonoToReal(log.logMonoTime);
                
                let dataHtml = '';
                if (log.data) {
                    dataHtml = `<div class="log-data small">${formatLogData(log.data)}</div>`;
                }

                return `
                    <div class="log-entry ${log.type}">
                        <div class="d-flex justify-content-between align-items-start">
                            <span class="log-type small">${log.type}</span>
                            <span class="log-time" title="Mono: ${log.logMonoTime}">
                                ${realTime ? realTime : time}
                            </span>
                        </div>
                        ${dataHtml}
                    </div>
                `;
            }).join('');
            
            if (filteredLogs.length > 200) {
                container.innerHTML += `<div class="text-secondary small text-center py-2">Showing 200 of ${filteredLogs.length} entries</div>`;
            }
        }

        // Log filter handlers
        document.getElementById('log-filters').addEventListener('click', (e) => {
            if (e.target.matches('button')) {
                document.querySelectorAll('#log-filters button').forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');
                activeFilter = e.target.dataset.type;
                renderLogs();
            }
        });

        // Utility functions
        function formatDateTime(routeTime) {
            if (!routeTime) return 'Unknown';
            const match = routeTime.match(/(\d{4})-(\d{2})-(\d{2})--(\d{2})-(\d{2})-(\d{2})/);
            if (match) {
                const [, year, month, day, hour, min, sec] = match;
                const date = new Date(year, month - 1, day, hour, min, sec);
                return formatTimeWithTZ(date);
            }
            return routeTime;
        }

        function formatLogTime(monoTime) {
            const seconds = monoTime / 1e9;
            const minutes = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${minutes}:${secs.padStart(4, '0')}`;
        }

        function convertMonoToReal(monoTime) {
            if (!timeCorrection || !timeCorrection.baseTimeMs || !timeCorrection.monoOffset) {
                return null;
            }
            const offsetNs = monoTime - timeCorrection.monoOffset;
            const offsetMs = offsetNs / 1e6;
            const realTimeMs = timeCorrection.baseTimeMs + offsetMs;
            return new Date(realTimeMs).toLocaleTimeString();
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
        }

        function formatLogData(data) {
            if (!data) return '';
            
            const parts = [];
            for (const [key, value] of Object.entries(data)) {
                if (value === null || value === undefined) continue;
                
                let displayValue = value;
                if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                } else if (typeof value === 'number') {
                    displayValue = Number.isInteger(value) ? value : value.toFixed(2);
                }
                
                parts.push(`<span class="text-info">${key}</span>: ${displayValue}`);
            }
            
            return parts.join(' | ');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            initPlayer();
            setupKeyboardShortcuts();
            await checkCapabilities();
            loadConfig();
            loadRoutes();
            
            // Show streaming capability status
            if (serverCapabilities.streaming) {
                console.log('FFmpeg streaming available - HEVC videos will be transcoded to H.264');
            }
        });
    </script>
</body>
</html>
